// Clear debug consolevar bt = new BridgeTalk();bt.target = 'estoolkit-4.0';bt.body = function(){    app.clc();    }.toSource()+"()";bt.send(5);// global variables for the XML node Find Featurevar foundNode=false;//var xarray =[];//var tempXArray =[];//var currLvl=0;//var myXML = <root><obj a1="01" a2="02" ><rc1>rc1</rc1></obj><temp></temp></root > ;var where="";foundNode=false;// Set up the namespace for the documentvar ns =new Namespace("http://ns.adobe.com/xfl/2008/");default xml namespace = ns;// Setup// Process the Campaign file and get the text nodes.#include "RCFunctions.js" // RC Functions ignore line#include "json2.js" // JSON2 Parser ignore:linevar script_file = File($.fileName); // get the location of the script filevar script_file_path = script_file.path; // get the pathvar file_to_read = File(script_file_path + "/CampaignText-Samsung.json");// but we want JSONvar my_JSON_object = null; // create an empty variablevar content; // this will hold the String content from the file// Look for the JSON Reference file, var errorStopProcessing=false;if(file_to_read !== false){// if it is really there    file_to_read.open('r'); // open it    content = file_to_read.read(); // read it    my_JSON_object =  JSON.parse(content);// now evaluate the string from the file    file_to_read.close(); // always close files after reading    } else {    alert("Something went wrong in the parse"); // if something went wrong    errorStopProcessing=true;}// Stop processing if no JSON file in found.if (!errorStopProcessing) {    ///////////////////////////////////////////////////////////////////////////////    // Work out which OS platform we are running on    // Ask the user to point to the folder for XFL file & Text processing    ///////////////////////////////////////////////////////////////////////////////    if (isOSX()) {        // House Keeping for wrunning the script on OSX        // Get Relative Folder location. This ensures that the script can run anywhere, in particular when shared on Creative Cloud.        var relativePath = getRelativePath();                $.writeln ( "Based from Relative Path = " + relativePath);        // Ask user to select the processing file      //   var baseFolder = File.openDialog('Select a processing Folder', function (f) { return (f instanceof Folder); } );      var inputFolder = Folder.selectDialog("Select a folder of documents to process");      //   alert ("inputFolder " +inputFolder);       // var csvFile = File.openDialog('Select a CSV File', function (f) { return (f instanceof Folder) || f.name.match(/\.csv$/i);} );    } else{        // Windows Processing - Needs to be completed, if required.        var csvFile = File.openDialog('Select a CSV File','comma-separated-values(*.csv):*.csv;');    }    // Process AI files. & Global Variables    // gFileTypesToFind - A list of file extensions to read    gFileTypesToFind = Array( "ai");    // gListofFilestoProcess - Used to store a list of folders to process     gListofFilestoProcess = new Array ();    lastFolderProcessed= new String();    //gXMLFileTypesToFind = Array( "ai");    //gXMLFileTypesToFind = Array( "xml");    fileFound = false;    ///////////////////////////////////////////////////////////////////////////////    // Return array of folder names for XFL processing based on the folder that the user chooses.    // Main logic processing    ///////////////////////////////////////////////////////////////////////////////    $.writeln("Processing the folders to read, from the base that was selected by the user");    gFindFilesProcess(inputFolder, gFileTypesToFind);    // Show the folders that we are going to tprocess as part of the next steps.    //for (f=0;f<gListofFilestoProcess.length;f++) {    //    $.writeln("items in process list = "+gListofFilestoProcess[f])    //}    // Quick way to stop and start this section of the processing    if (true==true) {        // This function will read the folders from the selected base folder that contain AI files.         // When an AI file is found, it's opened, and the text is changed as defined in the JSON Definition file.        for (readAIFolder=0;readAIFolder < gListofFilestoProcess.length;readAIFolder++) {            var fileList = gListofFilestoProcess[readAIFolder].getFiles();            var textFilesToOpen = [];            for ( var flIndex = 0; flIndex < fileList.length; flIndex++ ) {            if (fileList[flIndex] instanceof File ) {                $.writeln("Processing the files - " + fileList[flIndex]);                        // Find Illustrator files to process from the global variable - gFileTypesToFind                    var foundFileType = IsFileOneOfThese( fileList[flIndex],gFileTypesToFind);                    //  Found type of doc                     if (foundFileType) {                        //make sure it's the correct name                         openAndProcessAI(fileList[flIndex],true);                    }                }            }        }    } // remove one finished debugging    //////////////////    //Process the XFL files    // A list of file extensions to skip, keep them lower case        gFileTypesToFind = Array( "xfl");    gListofFilestoProcess = new Array ();    lastFolderProcessed= new String();    gXMLFileTypesToFind = Array( "xml");    fileFound = false;    ///////////////////////////////////////////////////////////////////////////////    // Return array of folder names for XFL processing based on the folder that the user chooses.    // Main logic processing    ///////////////////////////////////////////////////////////////////////////////    // Quick way to start and stop this part of the process.    if (true == true) {        gFindFilesProcess(inputFolder, gFileTypesToFind);        //Read folders that contain the Animate CC RAW XML / XFL files        for (readXFLFolder=0;readXFLFolder < gListofFilestoProcess.length;readXFLFolder++) {                var fileList = gListofFilestoProcess[readXFLFolder].getFiles();                var textFilesToOpen = [];                for ( var flIndex = 0; flIndex < fileList.length; flIndex++ ) {                if (fileList[flIndex] instanceof File ) {                    // Find XFL files                    var foundFileType = IsFileOneOfThese( fileList[flIndex],gXMLFileTypesToFind);//                      Found type of doc XML,                    if (foundFileType) {                        //make sure it's the correct name                      if (fileList[flIndex].toString().substr( fileList[flIndex].toString().lastIndexOf( "/" )+1, fileList[flIndex].length ) == "DOMDocument.xml") {                        //  ProcessDomDocXMLfile for each XFL definition file                         XMLFilesToOpen = processDomDocFile(fileList[flIndex]);                         // Process each XFL linked XML Text file                        // call the processing and pass thru the folder that we are working with.                         openAndProcessEachXFL_XMLFile(XMLFilesToOpen,gListofFilestoProcess[readXFLFolder]);                      }                    }                }            }        }    } // turned off temporarily} // end of stop processing.///////////////////////////////////////////////////////////////////////////////// processDomDocFile- Read the DomDocument file, this is the core of the XFL Animate CC file.// This function reads the XFL file and reads each HREF on the Symbols node// Symnbols node contains the links to the XML files that contain the Image referneces and text references./////////////////////////////////////////////////////////////////////////////////function processDomDocFile(filename) {           var stopReadingDomDoc=false;    var targetXMLFiles = [];     var file_to_read = File(filename);    file_to_read.open('r'); // open it    content = file_to_read.read(); // read it    var myXML = new XML(content);    var DomDocDescendents=myXML.descendants(); // can speficit the node here as well        for (var idesc=0;idesc<DomDocDescendents.length() && stopReadingDomDoc==false;idesc++) {        var ns_name = DomDocDescendents[idesc].name();        $.writeln(ns_name.localName);        if (ns_name.localName == "symbols") {                var symbolsXML=myXML.descendants("symbols");                stopReadingDomDoc=true;        }     }        var symbolDescLength = symbolsXML.descendants().length();    var symbolDescendents = symbolsXML.descendants();    for (var o=0;o<symbolDescendents.length();o++) {            var includeAttrs = getAttributes(symbolDescendents[o].toXMLString());        // attributres on include 2 is Href        //getFile name (no extension)        var substrStartPosn=0;        var substrEndPosn = includeAttrs[2][1].toString().lastIndexOf( "." );        var xfileName ="";        if (includeAttrs[2][1].toString().lastIndexOf( "/") >0) {            substrStartPosn = includeAttrs[2][1].toString().lastIndexOf( "/")+1;            xfileName = includeAttrs[2][1].toString().substr(substrStartPosn,includeAttrs[2][1].toString().length);            xfileName = xfileName.substr(0,xfileName.lastIndexOf( "." ));            }     else {                xfileName = includeAttrs[2][1].toString().substr(substrStartPosn,substrEndPosn);      }    // Is there a value in teh JSON Object?    if (my_JSON_object.hasOwnProperty(xfileName)) {            // push both file name the JSON Reference.            targetXMLFiles.push(includeAttrs[2][1]+"|"+xfileName);                     }    }    var attributes = getAttributes(symbolsXML);         return  targetXMLFiles;}///////////////////////////////////////////////////////////////////////////////// openAndProcessEachXFLTextFile - for each set of XML files that we need to target, will open and update the texto the new JSON files ///////////////////////////////////////////////////////////////////////////////function openAndProcessEachXFL_XMLFile(textFilesToOpen,foldername) {    // open each file     for (tfoidx=0;tfoidx<textFilesToOpen.length;tfoidx++) {        // Split the index value by a |        var splitdata=textFilesToOpen[tfoidx].split('|');                // Look at the Library folder within the XFL, this is where the XML files that contain the text references.        var fileNametoOpen = foldername + "/LIBRARY/"+ splitdata[0];             //open the correct file Name                var config = new File(fileNametoOpen);        config.open("r");          config.encoding = "UTF8";        var xmlString = config.read();          var myXML = new XML(xmlString);          // Reset the current level of the node searcher        currLvl=0;        foundNode=false;        where ="";        findNodeList(myXML,"DOMTextRun",where);                if (foundNode) {            $.writeln("file to open=" + fileNametoOpen)            // update characters on the text node            // pass in the JSON object which is related to the open file (i.e. CTA.xml will refer to CTA in the JSON file.            $.writeln("where, node list = " + where+".characters");            var JSONNode = eval("my_JSON_object."+splitdata[1]);            $.writeln("updating from JSON="+JSONNode);                        changeNodeValues(fileNametoOpen, where,JSONNode, "http://ns.adobe.com/xfl/2008/", "Y");        }    config.close();    }}///////////////////////////////////////////////////////////////////////////////// findNodeList - find to see if a node exists in a DOM structure, as well as list the parent nodes.// needs global variables//// var foundNode=false;// var where="";///////////////////////////////////////////////////////////////////////////////function findNodeList(XMLtree,nodeToFind,xWhere) {        $.writeln("found node = "+xWhere);    $.writeln("found node = "+foundNode);      if (foundNode==false) {           //var tempWhere="";           var tempWhere;          var DomDescendents=XMLtree.elements(); // can speficit the node here as well          // if end of a chain and nothing found, then reset the foundnodelist         // If there are no more elements to process and nothing was found, then reset all variables.         $.writeln("Dom descendents length = "+ DomDescendents.length());          if (DomDescendents.length()==0 ){              if (!foundNode) {                $.writeln("nothing found");                tempWhere="";                xWhere="";                where="";                currentNode="";              }           }                 // read ech element that exists in the loop                 for (var idesc=0;idesc<DomDescendents.length();idesc++ ) {              $.writeln("CURRENT idesc="+idesc);              $.writeln("dd length="+DomDescendents.length());        // as long as the mathcing node has not been found, process more elements           if (foundNode==false ) {                //. Found something                // for each element found                $.writeln("dom desc="+DomDescendents[idesc]);                var ns_name = DomDescendents[idesc].localName();                var currentNode;                // looping ot the current level, so rest the current node                  currentNode=xWhere+"."+ns_name;               // what's the value of tempwhere?                              }               // store the parent            // if an element was found to match, then fail all and pass back the current node string.            if (ns_name==nodeToFind) {                                tempwhere=ns_name;                where = currentNode;                foundNode=true;                }     else {                    // if name does not match, then go to the next level                    tempwhere = findNodeList(DomDescendents[idesc],nodeToFind,currentNode);                }                            }            }    if (foundNode) {       return "";     } else {         return "";     }}///////////////////////////////////////////////////////////////////////////////// openAndProcessAI - process the Illustrator files before the Animate files// This function will open the illustrator file and replace the text elements. // If any graphics change from the Creative Cloud Library, they will be changed in the document as well and bring it upto date.///////////////////////////////////////////////////////////////////////////////function   openAndProcessAI(fileName,saveFile) {      $.writeln("Processing AI files");   sourceDoc = app.open(fileName);    //Ai file processing     // get layers length & name    var docLayers=[];    var xx = app.activeDocument.layers.length;        for (i=0;i<app.activeDocument.layers.length;i++) {            // Only Process the ones that are visbible in the document            if (app.activeDocument.layers[i].visible) {            //  my_JSON_object            var layerName = app.activeDocument.layers[i].name.split("_");                // Validate to see if there is a match from the visible layers to the JSON objects that will be replaced.                if (eval("my_JSON_object.hasOwnProperty('"+layerName[0]+"_"+layerName[1]+"')")) {                    // Record the layers that are visible and have a match in the JSON object                    docLayers.push(app.activeDocument.layers[i].name);                    // insert new line                       var newTextFrameData = eval("my_JSON_object."+layerName[0]+"_"+layerName[1]);                       // If a ":" exists in the replacing JSON object, then need to replace with a new line characted "\r"                       var newTextFrameArray = newTextFrameData.split(":");                       var newContents = "";                       for (TFA=0;TFA<newTextFrameArray.length;TFA++) {                           if (TFA>0) {                               newContents = newContents + "\r";                               }                           newContents = newContents+newTextFrameArray[TFA];                           }                       // Update the  visible layer in the document with the correct JSON replacment (and include new line if required                      app.activeDocument.layers.getByName(app.activeDocument.layers[i].name).textFrames[0].contents=newContents;                 }            }             }     // If need to save the actual file, then do or do not.    if (saveFile) {    app.activeDocument.close(SaveOptions.SAVECHANGES);    } else {    app.activeDocument.close(SaveOptions.DONOTSAVECHANGES);    }}///////////////////////////////////////////////////////////////////////////////// gFindFilesProcess- Find sub files or sub folder from  a known path// Global function which looks to find folders that contain a certain file type that need to be processed.// It access a global array (gListofFilestoProcess) to store the data that it finds (make sure that the array is initalised before this // function is called./////////////////////////////////////////////////////////////////////////////////function gFindFilesProcess(inputFolder, lFileTypesToFind,stopProcessing) {function gFindFilesProcess(inputFolder, lFileTypesToFind) {    // Given the a Folder of files, open them       //var filesOpened;      // $.write("file type list");      // $.writeln("global file list ="+gListofFilestoProcess);            var fileList = inputFolder.getFiles();        // We have a local stop processing control. If a file is found in a folder that is worth processing, then stop and record the folder        // Scope is local only (as this is a recursive function        var localStopProcessing=false;        // Read files and folders in the folder provided by the input parameter        for ( var i = 0; i < fileList.length; i++ ) {            // If already found a file that fits the type, then no point in processing more, just quit and record the folder which it appears in.            if (!localStopProcessing) {                // If a folder is found, then recurzive call this function to find more files and folders.                 if (fileList[i] instanceof Folder ) {                    gFindFilesProcess(fileList[i],lFileTypesToFind);                }                // If a file is found, then store the folder that it appears in and stop the local processing.                if (fileList[i] instanceof File ) {                // Find the specific file type                    var FileTypeFound = IsFileOneOfThese( fileList[i], lFileTypesToFind );                    if (FileTypeFound) {                    //      found a file type that we can process;, and store the folder that we are processing                            if (!localStopProcessing){                                gListofFilestoProcess.push(inputFolder);                                localStopProcessing=true;                             }                    }                }          }        }}